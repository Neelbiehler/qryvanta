---
title: Metadata Runtime
description: Core model for entities, fields, constraints, and publish lifecycle.
---

Phase status: implemented baseline with active expansion.

Metadata runtime defines business data as tenant-scoped metadata, then executes runtime APIs from published schema versions.

## Implemented Baseline

- Entity metadata (`/api/entities`) remains the root definition for logical and display names.
- Field metadata is managed per entity (`/api/entities/:entity_logical_name/fields`).
- Draft field metadata can be updated and deleted with explicit endpoints:
  - `PUT /api/entities/:entity_logical_name/fields/:field_logical_name`
  - `DELETE /api/entities/:entity_logical_name/fields/:field_logical_name`
- Publish lifecycle is versioned and immutable (`/api/entities/:entity_logical_name/publish`).
- Standalone forms are managed with dedicated endpoints (`/api/entities/:entity_logical_name/forms`).
- Standalone views are managed with dedicated endpoints (`/api/entities/:entity_logical_name/views`).
- Runtime record APIs read only the latest published schema (`/api/runtime/:entity_logical_name/records`).
- Tenant identity bootstrap ensures a default published `contact` entity and subject-to-contact runtime mapping.

## Field Model

Supported field types:

- `text`
- `number`
- `boolean`
- `date`
- `datetime`
- `json`
- `choice` (single-select, backed by entity option sets)
- `multichoice` (multi-select, backed by entity option sets)
- `relation` (many-to-one by target entity logical name)

Per-field constraints:

- `is_required`
- `is_unique` (excluding `json` fields)
- `default_value`
- `relation_target_entity` (required for `relation` fields)
- `option_set_logical_name` (required for `choice` and `multichoice` fields)
- `description` (optional freeform metadata)
- `max_length` (optional, `text` fields only)
- `min_value` / `max_value` (optional, `number` fields only)

Field mutation rules:

- Published fields keep stable identity/type semantics: `logical_name` and `field_type` are immutable.
- Draft fields can be deleted only when they do not exist in any published schema version.
- Validation rejects invalid constraint combinations (for example `max_length` on `number` fields).

## Option Sets

Option sets are first-class metadata objects scoped to an entity and used by `choice`/`multichoice` fields.

- List/create: `GET/POST /api/entities/:entity_logical_name/option-sets`
- Read/update/delete: `GET/PUT/DELETE /api/entities/:entity_logical_name/option-sets/:option_set_logical_name`
- Published schema snapshots include resolved option set definitions.
- Runtime validation enforces that choice values exist in the referenced option set.

## Entity Metadata Enrichment

Entity definitions support optional descriptive fields in addition to logical and display names:

- `description`
- `plural_display_name`
- `icon`

## Form and View Definitions

Forms and views are standalone metadata definitions (not embedded inside app bindings) and are scoped per entity.

- Forms:
  - List/create: `GET/POST /api/entities/:entity_logical_name/forms`
  - Read/update/delete: `GET/PUT/DELETE /api/entities/:entity_logical_name/forms/:form_logical_name`
  - Saved definitions validate referenced field names against the latest published schema.
- Views:
  - List/create: `GET/POST /api/entities/:entity_logical_name/views`
  - Read/update/delete: `GET/PUT/DELETE /api/entities/:entity_logical_name/views/:view_logical_name`
  - Column, default sort, and filter field references validate against the latest published schema.

Current invariants:

- Forms require at least one tab; each tab requires at least one section.
- `quick_create` forms must contain exactly one tab and one section.
- Forms reject duplicate field placements.
- Views require at least one column and reject duplicate columns.

## Publish Lifecycle

1. Create/edit draft metadata (`entity_definitions` + `entity_fields`).
2. Publish immutable schema snapshot (`entity_published_versions`).
3. Runtime CRUD uses latest published version only.
4. Draft changes are inert until next publish.

## Runtime Validation

- Runtime payload must be a JSON object.
- Unknown fields are rejected.
- Required fields must be present unless a default is provided.
- Field values are type-checked deterministically.
- Relation values must reference an existing target runtime record.
- Unique constraints are enforced via a tenant/entity/field hash index.
- Runtime record deletion is blocked when incoming relation references still exist.

Validation failures are surfaced through `AppError::Validation` and mapped to `400 Bad Request`.

## Runtime Query

- `GET /api/runtime/:entity_logical_name/records` supports offset pagination.
- `POST /api/runtime/:entity_logical_name/records/query` supports typed filter/sort with recursive logical groups and link-entity aliases.
- Filter operators include `eq`, `neq`, `gt`, `gte`, `lt`, `lte`, `contains`, and `in`.
- Query sorting supports explicit field sort order (`asc`/`desc`) for typed runtime fields, including alias scopes.
- Link entities support `inner` and `left` join behavior through relation fields on the parent scope.
- Filter/sort fields must exist in the published schema for the selected scope (root entity or alias target).
- Runtime query access requires runtime read permission and tenant-scoped repository access.

Query payload grammar:

- `limit` (`number`) and `offset` (`number`) control pagination.
- `logical_mode` (`"and" | "or"`) controls legacy top-level `conditions` composition.
- `conditions` (`Array<{ scope_alias?, field_logical_name, operator, field_value }>` ) remains supported for flat condition lists.
- `where` (`{ logical_mode?, conditions?, groups? }`) defines recursive condition trees.
- `link_entities` (`Array<{ alias, parent_alias?, relation_field_logical_name, join_type? }>` ) defines alias scopes.
- `sort` (`Array<{ scope_alias?, field_logical_name, direction }>` ) applies stable field ordering.
- `filters` (`Record<string, unknown>`) remains an optional compatibility input for root exact-match constraints.

Compatibility notes:

- Existing clients that send only `logical_mode` + `conditions` + `filters` continue to work.
- New query paths can mix root and alias-scoped clauses as metadata model complexity grows.

Route list and endpoint grouping are maintained in `API Conventions`.
