---
title: Metadata Runtime
description: Core model for entities, fields, constraints, and publish lifecycle.
---

Phase status: implemented baseline with active expansion.

Metadata runtime defines business data as tenant-scoped metadata, then executes runtime APIs from published schema versions.

## Implemented Baseline

- Entity metadata (`/api/entities`) remains the root definition for logical and display names.
- Field metadata is managed per entity (`/api/entities/:entity_logical_name/fields`).
- Publish lifecycle is versioned and immutable (`/api/entities/:entity_logical_name/publish`).
- Runtime record APIs read only the latest published schema (`/api/runtime/:entity_logical_name/records`).
- Tenant identity bootstrap ensures a default published `contact` entity and subject-to-contact runtime mapping.

## Field Model

Supported field types:

- `text`
- `number`
- `boolean`
- `date`
- `datetime`
- `json`
- `relation` (many-to-one by target entity logical name)

Per-field constraints:

- `is_required`
- `is_unique` (excluding `json` fields)
- `default_value`
- `relation_target_entity` (required for `relation` fields)

## Publish Lifecycle

1. Create/edit draft metadata (`entity_definitions` + `entity_fields`).
2. Publish immutable schema snapshot (`entity_published_versions`).
3. Runtime CRUD uses latest published version only.
4. Draft changes are inert until next publish.

## Runtime Validation

- Runtime payload must be a JSON object.
- Unknown fields are rejected.
- Required fields must be present unless a default is provided.
- Field values are type-checked deterministically.
- Relation values must reference an existing target runtime record.
- Unique constraints are enforced via a tenant/entity/field hash index.
- Runtime record deletion is blocked when incoming relation references still exist.

Validation failures are surfaced through `AppError::Validation` and mapped to `400 Bad Request`.

## Runtime Query

- `GET /api/runtime/:entity_logical_name/records` supports offset pagination.
- `POST /api/runtime/:entity_logical_name/records/query` supports typed filter/sort with recursive logical groups and link-entity aliases.
- Filter operators include `eq`, `neq`, `gt`, `gte`, `lt`, `lte`, `contains`, and `in`.
- Query sorting supports explicit field sort order (`asc`/`desc`) for typed runtime fields, including alias scopes.
- Link entities support `inner` and `left` join behavior through relation fields on the parent scope.
- Filter/sort fields must exist in the published schema for the selected scope (root entity or alias target).
- Runtime query access requires runtime read permission and tenant-scoped repository access.

Query payload grammar:

- `limit` (`number`) and `offset` (`number`) control pagination.
- `logical_mode` (`"and" | "or"`) controls legacy top-level `conditions` composition.
- `conditions` (`Array<{ scope_alias?, field_logical_name, operator, field_value }>` ) remains supported for flat condition lists.
- `where` (`{ logical_mode?, conditions?, groups? }`) defines recursive condition trees.
- `link_entities` (`Array<{ alias, parent_alias?, relation_field_logical_name, join_type? }>` ) defines alias scopes.
- `sort` (`Array<{ scope_alias?, field_logical_name, direction }>` ) applies stable field ordering.
- `filters` (`Record<string, unknown>`) remains an optional compatibility input for root exact-match constraints.

Compatibility notes:

- Existing clients that send only `logical_mode` + `conditions` + `filters` continue to work.
- New query paths can mix root and alias-scoped clauses as metadata model complexity grows.

Route list and endpoint grouping are maintained in `API Conventions`.
