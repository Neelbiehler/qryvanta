---
title: Metadata Runtime
description: Core model for entities, fields, constraints, and publish lifecycle.
---

Phase status: implemented baseline with active expansion.

Metadata runtime defines business data as tenant-scoped metadata, then executes runtime APIs from published schema versions.

## Implemented Baseline

- Entity metadata (`/api/entities`) remains the root definition for logical and display names.
- Field metadata is managed per entity (`/api/entities/:entity_logical_name/fields`).
- Draft field metadata can be updated and deleted with explicit endpoints:
  - `PUT /api/entities/:entity_logical_name/fields/:field_logical_name`
  - `DELETE /api/entities/:entity_logical_name/fields/:field_logical_name`
- Publish lifecycle is versioned and immutable (`/api/entities/:entity_logical_name/publish`).
- Standalone forms are managed with dedicated endpoints (`/api/entities/:entity_logical_name/forms`).
- Standalone views are managed with dedicated endpoints (`/api/entities/:entity_logical_name/views`).
- Runtime record APIs read only the latest published schema (`/api/runtime/:entity_logical_name/records`).
- Tenant identity bootstrap ensures a default published `contact` entity and subject-to-contact runtime mapping.

## Field Model

Supported field types:

- `text`
- `number`
- `boolean`
- `date`
- `datetime`
- `json`
- `choice` (single-select, backed by entity option sets)
- `multichoice` (multi-select, backed by entity option sets)
- `relation` (many-to-one by target entity logical name)

Per-field constraints:

- `is_required`
- `is_unique` (excluding `json` fields)
- `default_value`
- `relation_target_entity` (required for `relation` fields)
- `option_set_logical_name` (required for `choice` and `multichoice` fields)
- `calculation_expression` (optional, computed runtime value for `text` and `number` fields)
- `description` (optional freeform metadata)
- `max_length` (optional, `text` fields only)
- `min_value` / `max_value` (optional, `number` fields only)

Field mutation rules:

- Published fields keep stable identity/type semantics: `logical_name` and `field_type` are immutable.
- Draft fields can be deleted only when they do not exist in any published schema version.
- Validation rejects invalid constraint combinations (for example `max_length` on `number` fields).
- Calculated fields cannot define `default_value` and cannot be directly set by runtime clients.

## Calculated Fields (v1)

Calculated fields are evaluated in the API runtime on create/update writes after payload normalization.

- Supported functions:
  - `add(arg1, arg2, ...)` → numeric sum
  - `concat(arg1, arg2, ...)` → text concatenation
- Arguments can reference other field logical names, numeric literals, or quoted string literals.
- Calculated fields are persisted in runtime record payloads like normal fields, but are always derived from expression output.

## Option Sets

Option sets are first-class metadata objects scoped to an entity and used by `choice`/`multichoice` fields.

- List/create: `GET/POST /api/entities/:entity_logical_name/option-sets`
- Read/update/delete: `GET/PUT/DELETE /api/entities/:entity_logical_name/option-sets/:option_set_logical_name`
- Published schema snapshots include resolved option set definitions.
- Runtime validation enforces that choice values exist in the referenced option set.

## Entity Metadata Enrichment

Entity definitions support optional descriptive fields in addition to logical and display names:

- `description`
- `plural_display_name`
- `icon`

Entity metadata can be updated after creation via `PUT /api/entities/:entity_logical_name` to change display name, description, plural display name, and icon without altering the immutable logical name.

## Form and View Definitions

Forms and views are standalone metadata definitions (not embedded inside app bindings) and are scoped per entity.

- Forms:
  - List/create: `GET/POST /api/entities/:entity_logical_name/forms`
  - Read/update/delete: `GET/PUT/DELETE /api/entities/:entity_logical_name/forms/:form_logical_name`
  - Saved definitions validate referenced field names against the latest published schema.
- Views:
  - List/create: `GET/POST /api/entities/:entity_logical_name/views`
  - Read/update/delete: `GET/PUT/DELETE /api/entities/:entity_logical_name/views/:view_logical_name`
  - Column, default sort, and filter field references validate against the latest published schema.

Current invariants:

- Forms require at least one tab; each tab requires at least one section.
- `quick_create` forms must contain exactly one tab and one section.
- Forms reject duplicate field placements.
- Views require at least one column and reject duplicate columns.

## Auto-Generated Defaults on Publish

When an entity is published, the system automatically generates convention-based defaults if they do not already exist:

- **Default Main Form** (`main_form`): A `Main` form type with all published fields placed in a single "General" tab and section using a two-column layout. Auto-generation is skipped if any form with `form_type: main` already exists for the entity.
- **Default "All Records" View** (`all_records`): A `Grid` view type containing all published fields as columns, sorted ascending by the first field, and marked as the default view. Auto-generation is skipped if any view marked `is_default: true` already exists for the entity.

This follows the convention-over-configuration principle: makers get a working app immediately after their first publish, and only need to customize what deviates from the default layout.

## Publish Lifecycle

1. Create/edit draft metadata (`entity_definitions` + `entity_fields`).
2. Publish immutable schema snapshot (`entity_published_versions`).
3. Auto-generate default form and view if none exist.
4. Runtime CRUD uses latest published version only.
5. Draft changes are inert until next publish.

## Runtime Validation

- Runtime payload must be a JSON object.
- Unknown fields are rejected.
- Required fields must be present unless a default is provided.
- Field values are type-checked deterministically.
- Text field `max_length` is enforced on runtime writes.
- Number field `min_value` / `max_value` constraints are enforced on runtime writes.
- Calculated field expressions are evaluated server-side on runtime writes.
- Runtime payloads that attempt to set calculated fields directly are rejected.
- Active entity-scoped business rules execute during runtime writes: validation actions (`show_error`) block writes, value actions (`set_default_value`, `set_field_value`) patch payloads, and requiredness actions (`set_required`, `set_optional`) adjust required checks.
- Relation values must reference an existing target runtime record.
- Unique constraints are enforced via a tenant/entity/field hash index.
- Runtime record deletion is blocked when incoming relation references still exist.

Validation failures are surfaced through `AppError::Validation` and mapped to `400 Bad Request`.

## Runtime Query

- `GET /api/runtime/:entity_logical_name/records` supports offset pagination.
- `POST /api/runtime/:entity_logical_name/records/query` supports typed filter/sort with recursive logical groups and link-entity aliases.
- Filter operators include `eq`, `neq`, `gt`, `gte`, `lt`, `lte`, `contains`, and `in`.
- Query sorting supports explicit field sort order (`asc`/`desc`) for typed runtime fields, including alias scopes.
- Link entities support `inner` and `left` join behavior through relation fields on the parent scope.
- Filter/sort fields must exist in the published schema for the selected scope (root entity or alias target).
- Runtime query access requires runtime read permission and tenant-scoped repository access.

Query payload grammar:

- `limit` (`number`) and `offset` (`number`) control pagination.
- `logical_mode` (`"and" | "or"`) controls legacy top-level `conditions` composition.
- `conditions` (`Array<{ scope_alias?, field_logical_name, operator, field_value }>` ) remains supported for flat condition lists.
- `where` (`{ logical_mode?, conditions?, groups? }`) defines recursive condition trees.
- `link_entities` (`Array<{ alias, parent_alias?, relation_field_logical_name, join_type? }>` ) defines alias scopes.
- `sort` (`Array<{ scope_alias?, field_logical_name, direction }>` ) applies stable field ordering.
- `filters` (`Record<string, unknown>`) remains an optional compatibility input for root exact-match constraints.

Compatibility notes:

- Existing clients that send only `logical_mode` + `conditions` + `filters` continue to work.
- New query paths can mix root and alias-scoped clauses as metadata model complexity grows.

Route list and endpoint grouping are maintained in `API Conventions`.
